<!DOCTYPE html>
<html lang="pt">
  <head>
    <title>Tipos de dados, variáveis e constantes – @goenning</title>

    <meta charset="utf-8" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link rel="stylesheet" type="text/css" href="/style.css" />  <!-- Icons -->
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="alternate" type="application/rss+xml" title="@goenning - loop at { run; code; blog; swim; eat; cycle; } until tired;" href="/feed.xml" />
    

    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Tipos de dados, variáveis e constantes | @goenning</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Tipos de dados, variáveis e constantes" />
<meta name="author" content="@goenning" />
<meta property="og:locale" content="pt" />
<meta name="description" content="Conhecer o fundamento dos tipos de dados e suas opções é essencial para podermos construir programas de qualidade, principalmente a partir da versão 4.5 onde a linguagem passou a suportar os modelos de programação estruturado e orientado a objetos de forma mista. Parece besteira, mas o funcionamento dos tipos de dados em ABAP possui uma diferença considerável quando comparada com outras linguagens. A imagem abaixo ajuda a enxergarmos todas as possibilidades. Note que a imagem acima quebra os tipos de dados em três categorias: Elementary Types, Complex Types e Reference Types. Vamos dar uma olhada em cada um deles e suas diferenças. Elementary Types Também conhecidos como tipos primitivos, estes são os famosos tipos de dados que encontramos em todas as linguagens. Temos o Inteiro, o Caractere, Data e Hora como bons exemplos. A definição de variáveis é feita com o comando DATA conforme mostra o exemplo abaixo. REPORT zvariaveis. DATA: cep(8) TYPE n, nome(20) TYPE c, idade TYPE i. Vale a pena ressaltar a diferença entre C (CHAR) e N (NUMC) que geralmente causa bastante confusão. N possui o mesmo comportamento do tipo C com a única diferença que este só pode armazenar valores numéricos. Ele ocupa a mesma quantidade de bytes em memória e é sempre representado com zeros à esquerda até preencher o comprimento total da variável. Também é possível utilizarmos variáveis deste tipo em operações matemáticas como adição, subtração e até comparação maior ou menor. No início pode parecer um tanto quanto estranho usar o tipo N se temos o I, mas ao longo do tempo você perceberá que a SAP faz uso extensivo deste de NUNC e logo você estará fazendo isto também. Nas chaves primárias de tabelas, por exemplo, sempre será utilizado NUMC. Um dos motivos para isto é justamente a garantia do tamanho fixo que este tipo de dado possui, pois em muitos lugares o SAP armazena a chave primária das tabelas de forma concatenada. Nestes casos é obrigatório que os campos da chave tenham um tamanho fixo para que seja possível fazer as devidas conversão na concatenaçao. Há ainda os tipos de dados de tamanho variável: STRING e XSTRING. Diferente de CHAR, o STRING pode crescer o quanto for necessário, sendo então o tipo de dado ideal para armazenar uma grande quantidade de texto como o conteúdo de um arquivo ou de um documento XML, por exemplo. Complex Types No ABAP também é possível criarmos nossas próprias estruturas de dados. Isto é muito útil quando é necessário agrupar um conjunto de informações em uma única variável. São dois passos para usar estas estruturas. A primeira é criar a estrutura usando a instrução TYPES. A segunda é criar uma instância deste tipo da mesma forma que fizemos até agora, usando a instrução DATA. REPORT zvariaveis. TYPES: BEGIN OF t_pessoa, nome(20) TYPE c, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. DATA: homem TYPE t_pessoa, mulher TYPE t_pessoa. homem-nome = &quot;Joao&quot;. homem-idade = 22. homem-peso = &#39;72.51&#39;. mulher-nome = &quot;Maria&quot;. mulher-idade = 19. mulher-peso = &#39;68.2&#39;. Para quem já trabalhou com outras linguagens, note que no ABAP o acesso aos campos é feito com hífen ao invés de ponto, isto causa bastante confusão em quem está inciando. O ‘ponto’ sempre será usado para definir o final de uma linha de código. Também é possível criarmos uma estrutura de dados que se comporta como uma hierarquia, onde o tipo de um campo referencia outro tipo complexo. Ahm?! Não entendeu? O exemplo abaixo deve ajudar na explicação. Transformei o campo nome em outra estrutura de dados. REPORT zvariaveis. TYPES: BEGIN OF t_nome, primeiro(20) TYPE c, ultimo(20) TYPE c, END OF t_nome, BEGIN OF t_pessoa, nome TYPE t_nome, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. DATA: homem TYPE t_pessoa, mulher TYPE t_pessoa. homem-nome-primeiro = &#39;Joao&#39;. homem-nome-ultimo = &#39;Braga&#39;. Ainda em se tratando de tipos complexos temos também as Tabelas Internas. A tabela interno é possivelmente um dos tipos de variável mais usado em programas ABAP, então se este assunto for novidade para você, sugiro estudá-lo e praticá-lo bastante. Uma tabela interno é muito semelhante a uma tabela de banco de dados. A grande diferença é que ela nasce e morre dentro de um contexto de um programa, ou seja, os dados inseridos nesta tabela não são armazenados em disco. Poderíamos chamá-las também de tabela temporária, porém este termo não é usado no ambiente ABAP. Quando trabalhamos com uma tabela interna é necessário declararmos uma variável do tipo tabela referenciando um outro tipo de dados, podendo ser um Elementary Type ou Complex Type. O tipo referenciado em uma tabela é conhecido como LINE TYPE. Veja o seguinte exemplo de declaração. REPORT zvariaveis. TYPES: BEGIN OF t_nome, primeiro(20) TYPE c, ultimo(20) TYPE c, END OF t_nome, BEGIN OF t_pessoa, nome TYPE t_nome, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. DATA: alunos TYPE STANDARD TABLE OF t_pessoa. Neste exemplo criei uma tabela chamada alunos onde o tipo da linha é t_pessoa. Esta variável/tabela pode conter uma quantidade infinita de registros, portanto torna-se útil quando não sabemos a quantidade de registros que precisamos. Se tivermos certeza de que será sempre dois registros, poderíamos criar duas variáveis básicas do tipo t_pessoa. No caso de um relatório de alunos matriculados em um curso, pode ser que tenhamos 1, 2, 3, 10, 40, 50 ou até mais alunos. Seria inviável criar uma variável para armazenar os dados de cada aluno, então este é um cenário onde devemos usar variáveis do tipo tabela. Comparando com outras linguagens, isto seria o mesmo que instanciar um objeto ArrayList (Java) ou List (C#) de uma classe qualquer. Para poder inserir registros nestas tabelas é necessário criar o que o ABAP chama de work area. Work area é uma variável do mesmo tipo de dado da tabela, porém representa apenas uma linha da tabela. Toda vez que for necessário inserir ou manipular um registro da tabela, é necessário fazer estas modificações primeiro na work area e depois repassar para a tabela. Confuso? Vamos ver se consigo explicar melhor com um exemplo. REPORT zvariaveis. TYPES: BEGIN OF t_nome, primeiro(20) TYPE c, ultimo(20) TYPE c, END OF t_nome, BEGIN OF t_pessoa, codigo type i, nome TYPE t_nome, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. * definição da tabela interna de alunos DATA: alunos TYPE STANDARD TABLE OF t_pessoa, * definição da work area para a tabela alunos wa_aluno type t_pessoa. * inserindo o primeiro registro de aluno na tabela de alunos wa_aluno-codigo = 1. wa_aluno-nome-primeiro = &#39;Albert&#39;. wa_aluno-nome-ultimo = &#39;Einstein&#39;. wa_aluno-idade = 42. wa_aluno-peso = &#39;70.2&#39;. insert wa_aluno into table alunos. * inserindo o segundo registro de aluno na tabela de alunos wa_aluno-codigo = 2. wa_aluno-nome-primeiro = &#39;Thomas&#39;. wa_aluno-nome-ultimo = &#39;Edison&#39;. wa_aluno-idade = 32. wa_aluno-peso = &#39;85.2&#39;. insert wa_aluno into table alunos. * mostrando na tela o nome completo e a idade dos dois alunos. LOOP AT alunos INTO wa_aluno. write: / wa_aluno-nome-primeiro, wa_aluno-nome-ultimo, wa_aluno-idade. ENDLOOP. * seleciona o aluno onde codigo for igual a 1 e o posiciona na work area READ table alunos INTO wa_aluno WITH KEY codigo = 1. IF sy-subrc = 0. * modifica a idade do aluno wa_aluno-idade = 30. * atualiza a tabela de alunos usando o indice encontrado na busca MODIFY alunos FROM wa_aluno INDEX sy-tabix. ENDIF. * mostrando na tela o nome completo dos dois alunos, com a idade atualizada LOOP AT alunos INTO wa_aluno. write: / wa_aluno-nome-primeiro, wa_aluno-nome-ultimo, wa_aluno-idade. ENDLOOP. Nestes exemplos eu sempre usei a tabela do tipo STANDARD. Mas também é possível usar HASHED ou SORTED. A diferença está na ordem com que os registros são inseridos e no desempenho durante os comandos de LOOP E READ TABLE. O artigo Performance de leitura por tipo de tabela explora bastante este assunto. Diferente formas de declarar uma variável. Em muitos exemplos de código na internet é possível notar o uso do comando LIKE na definição de uma variável. A diferença entre o TYPE e LIKE é que no TYPE você deve informar qual o tipo de dado da variável, eunquanto a declaração usando LIKE você informa uma outra variável existente para que esta nova variável copie a definição do tipo de dado. Este comando tornou-se obsoleto, pois não funciona com a versão orientada a objeto do ABAP. A SAP recomenda o uso de TYPE para todos os casos de declaração de variáveis. Também é muito comum encontrar exemplos onde a tabela interna é definida com HEADER LINE. Header line é uma forma de não ter que declarar uma work area para trabalhar com tabelas. Com o passar do tempo o uso de header line caiu em desuso e, apesar de ainda funcionar, não é mais recomendado. Reference Types Variáveis de referência foram adicionadas ao ABAP junto com o início do suporte à programação orientada à objetos. Referências são ponteiros que funcionam tanto para objetos quanto para os tipos de dados apresentados acima. Quando declaramos uma variável de referência seu conteúdo permanece vazio até que este seja criado com a instrução CREATE OBJECT ou CREATE DATA, ou então seja atribuída à uma variável que já existe com a instrução GET REFERENCE OF…INTO. A diferença entre CREATE DATA e CREATE OBJECT é que o primeiro é usado para criar referências à tipos de dados primários ou complexos, enquanto o segundo só funciona com classes ABAP. Segue abaixo um exemplo bem simples usando referências com um tipo de dado inteiro. DATA: lv_ref TYPE REF TO i, lv_value TYPE i. lv_value = 10. GET REFERENCE OF lv_value INTO lv_ref. WRITE lv_value. lv_ref-&amp;gt;* = 12. WRITE lv_value. Neste exemplo primeiro é impresso 10 e depois 12. Ou seja, o conteúdo da variável LV_VALUE foi alterado implicitamente, pois foi alteado pela variável de referência que estava apontando para ela. Este tipo de cenário é pouco explorado no ABAP, normalmente o uso mais visto para variáveis de referência é quando precisamos trabalhar com classes e objetos. Quando precisamos instanciar uma classe em ABAP fazemos o uso de CREATE OBJECT. Um exemplo bem familiar para muitos programadores ABAP é a classe CL_GUI_ALV_GRID que representa um elemento gráfico de um ALV (ABAP List Viewer, ou apenas Grid). DATA : lo_alv TYPE REF TO cl_gui_alv_grid. CREATE OBJECT lo_alv EXPORTING i_parent = lo_my_container. Neste cenário estamos criando uma instância em tempo de execução da classe CL_GUI_ALV_GRID e atribuindo-a à nossa variável de referência. É a partir deste momento que podemos fazer uso de seus métodos e propriedades sem resultado em um DUMP. O DUMP neste caso seria igual ao NullPointerException ou NullReferenceException do Java e C#, conhecem? Bônus: Constantes Não vou me estender muito neste assunto. Vou partir do princípio que você já sabe o que é uma constante e vou direto ao código que é o que interessa. CONSTANTS c_empresa(4) TYPE n VALUE 1001. Também é possível criar uma estrutura constante. Ficaria assim: CONSTANTS: BEGIN OF c_empresa, codigo(4) TYPE n VALUE &#39;1001&#39;, nome TYPE c VALUE &#39;SAP&#39; END OF c_empresa. WRITE: / c_empresa-codigo, c_empresa-nome. Espero que este post tenha sido útil. Até a próxima!" />
<meta property="og:description" content="Conhecer o fundamento dos tipos de dados e suas opções é essencial para podermos construir programas de qualidade, principalmente a partir da versão 4.5 onde a linguagem passou a suportar os modelos de programação estruturado e orientado a objetos de forma mista. Parece besteira, mas o funcionamento dos tipos de dados em ABAP possui uma diferença considerável quando comparada com outras linguagens. A imagem abaixo ajuda a enxergarmos todas as possibilidades. Note que a imagem acima quebra os tipos de dados em três categorias: Elementary Types, Complex Types e Reference Types. Vamos dar uma olhada em cada um deles e suas diferenças. Elementary Types Também conhecidos como tipos primitivos, estes são os famosos tipos de dados que encontramos em todas as linguagens. Temos o Inteiro, o Caractere, Data e Hora como bons exemplos. A definição de variáveis é feita com o comando DATA conforme mostra o exemplo abaixo. REPORT zvariaveis. DATA: cep(8) TYPE n, nome(20) TYPE c, idade TYPE i. Vale a pena ressaltar a diferença entre C (CHAR) e N (NUMC) que geralmente causa bastante confusão. N possui o mesmo comportamento do tipo C com a única diferença que este só pode armazenar valores numéricos. Ele ocupa a mesma quantidade de bytes em memória e é sempre representado com zeros à esquerda até preencher o comprimento total da variável. Também é possível utilizarmos variáveis deste tipo em operações matemáticas como adição, subtração e até comparação maior ou menor. No início pode parecer um tanto quanto estranho usar o tipo N se temos o I, mas ao longo do tempo você perceberá que a SAP faz uso extensivo deste de NUNC e logo você estará fazendo isto também. Nas chaves primárias de tabelas, por exemplo, sempre será utilizado NUMC. Um dos motivos para isto é justamente a garantia do tamanho fixo que este tipo de dado possui, pois em muitos lugares o SAP armazena a chave primária das tabelas de forma concatenada. Nestes casos é obrigatório que os campos da chave tenham um tamanho fixo para que seja possível fazer as devidas conversão na concatenaçao. Há ainda os tipos de dados de tamanho variável: STRING e XSTRING. Diferente de CHAR, o STRING pode crescer o quanto for necessário, sendo então o tipo de dado ideal para armazenar uma grande quantidade de texto como o conteúdo de um arquivo ou de um documento XML, por exemplo. Complex Types No ABAP também é possível criarmos nossas próprias estruturas de dados. Isto é muito útil quando é necessário agrupar um conjunto de informações em uma única variável. São dois passos para usar estas estruturas. A primeira é criar a estrutura usando a instrução TYPES. A segunda é criar uma instância deste tipo da mesma forma que fizemos até agora, usando a instrução DATA. REPORT zvariaveis. TYPES: BEGIN OF t_pessoa, nome(20) TYPE c, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. DATA: homem TYPE t_pessoa, mulher TYPE t_pessoa. homem-nome = &quot;Joao&quot;. homem-idade = 22. homem-peso = &#39;72.51&#39;. mulher-nome = &quot;Maria&quot;. mulher-idade = 19. mulher-peso = &#39;68.2&#39;. Para quem já trabalhou com outras linguagens, note que no ABAP o acesso aos campos é feito com hífen ao invés de ponto, isto causa bastante confusão em quem está inciando. O ‘ponto’ sempre será usado para definir o final de uma linha de código. Também é possível criarmos uma estrutura de dados que se comporta como uma hierarquia, onde o tipo de um campo referencia outro tipo complexo. Ahm?! Não entendeu? O exemplo abaixo deve ajudar na explicação. Transformei o campo nome em outra estrutura de dados. REPORT zvariaveis. TYPES: BEGIN OF t_nome, primeiro(20) TYPE c, ultimo(20) TYPE c, END OF t_nome, BEGIN OF t_pessoa, nome TYPE t_nome, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. DATA: homem TYPE t_pessoa, mulher TYPE t_pessoa. homem-nome-primeiro = &#39;Joao&#39;. homem-nome-ultimo = &#39;Braga&#39;. Ainda em se tratando de tipos complexos temos também as Tabelas Internas. A tabela interno é possivelmente um dos tipos de variável mais usado em programas ABAP, então se este assunto for novidade para você, sugiro estudá-lo e praticá-lo bastante. Uma tabela interno é muito semelhante a uma tabela de banco de dados. A grande diferença é que ela nasce e morre dentro de um contexto de um programa, ou seja, os dados inseridos nesta tabela não são armazenados em disco. Poderíamos chamá-las também de tabela temporária, porém este termo não é usado no ambiente ABAP. Quando trabalhamos com uma tabela interna é necessário declararmos uma variável do tipo tabela referenciando um outro tipo de dados, podendo ser um Elementary Type ou Complex Type. O tipo referenciado em uma tabela é conhecido como LINE TYPE. Veja o seguinte exemplo de declaração. REPORT zvariaveis. TYPES: BEGIN OF t_nome, primeiro(20) TYPE c, ultimo(20) TYPE c, END OF t_nome, BEGIN OF t_pessoa, nome TYPE t_nome, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. DATA: alunos TYPE STANDARD TABLE OF t_pessoa. Neste exemplo criei uma tabela chamada alunos onde o tipo da linha é t_pessoa. Esta variável/tabela pode conter uma quantidade infinita de registros, portanto torna-se útil quando não sabemos a quantidade de registros que precisamos. Se tivermos certeza de que será sempre dois registros, poderíamos criar duas variáveis básicas do tipo t_pessoa. No caso de um relatório de alunos matriculados em um curso, pode ser que tenhamos 1, 2, 3, 10, 40, 50 ou até mais alunos. Seria inviável criar uma variável para armazenar os dados de cada aluno, então este é um cenário onde devemos usar variáveis do tipo tabela. Comparando com outras linguagens, isto seria o mesmo que instanciar um objeto ArrayList (Java) ou List (C#) de uma classe qualquer. Para poder inserir registros nestas tabelas é necessário criar o que o ABAP chama de work area. Work area é uma variável do mesmo tipo de dado da tabela, porém representa apenas uma linha da tabela. Toda vez que for necessário inserir ou manipular um registro da tabela, é necessário fazer estas modificações primeiro na work area e depois repassar para a tabela. Confuso? Vamos ver se consigo explicar melhor com um exemplo. REPORT zvariaveis. TYPES: BEGIN OF t_nome, primeiro(20) TYPE c, ultimo(20) TYPE c, END OF t_nome, BEGIN OF t_pessoa, codigo type i, nome TYPE t_nome, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. * definição da tabela interna de alunos DATA: alunos TYPE STANDARD TABLE OF t_pessoa, * definição da work area para a tabela alunos wa_aluno type t_pessoa. * inserindo o primeiro registro de aluno na tabela de alunos wa_aluno-codigo = 1. wa_aluno-nome-primeiro = &#39;Albert&#39;. wa_aluno-nome-ultimo = &#39;Einstein&#39;. wa_aluno-idade = 42. wa_aluno-peso = &#39;70.2&#39;. insert wa_aluno into table alunos. * inserindo o segundo registro de aluno na tabela de alunos wa_aluno-codigo = 2. wa_aluno-nome-primeiro = &#39;Thomas&#39;. wa_aluno-nome-ultimo = &#39;Edison&#39;. wa_aluno-idade = 32. wa_aluno-peso = &#39;85.2&#39;. insert wa_aluno into table alunos. * mostrando na tela o nome completo e a idade dos dois alunos. LOOP AT alunos INTO wa_aluno. write: / wa_aluno-nome-primeiro, wa_aluno-nome-ultimo, wa_aluno-idade. ENDLOOP. * seleciona o aluno onde codigo for igual a 1 e o posiciona na work area READ table alunos INTO wa_aluno WITH KEY codigo = 1. IF sy-subrc = 0. * modifica a idade do aluno wa_aluno-idade = 30. * atualiza a tabela de alunos usando o indice encontrado na busca MODIFY alunos FROM wa_aluno INDEX sy-tabix. ENDIF. * mostrando na tela o nome completo dos dois alunos, com a idade atualizada LOOP AT alunos INTO wa_aluno. write: / wa_aluno-nome-primeiro, wa_aluno-nome-ultimo, wa_aluno-idade. ENDLOOP. Nestes exemplos eu sempre usei a tabela do tipo STANDARD. Mas também é possível usar HASHED ou SORTED. A diferença está na ordem com que os registros são inseridos e no desempenho durante os comandos de LOOP E READ TABLE. O artigo Performance de leitura por tipo de tabela explora bastante este assunto. Diferente formas de declarar uma variável. Em muitos exemplos de código na internet é possível notar o uso do comando LIKE na definição de uma variável. A diferença entre o TYPE e LIKE é que no TYPE você deve informar qual o tipo de dado da variável, eunquanto a declaração usando LIKE você informa uma outra variável existente para que esta nova variável copie a definição do tipo de dado. Este comando tornou-se obsoleto, pois não funciona com a versão orientada a objeto do ABAP. A SAP recomenda o uso de TYPE para todos os casos de declaração de variáveis. Também é muito comum encontrar exemplos onde a tabela interna é definida com HEADER LINE. Header line é uma forma de não ter que declarar uma work area para trabalhar com tabelas. Com o passar do tempo o uso de header line caiu em desuso e, apesar de ainda funcionar, não é mais recomendado. Reference Types Variáveis de referência foram adicionadas ao ABAP junto com o início do suporte à programação orientada à objetos. Referências são ponteiros que funcionam tanto para objetos quanto para os tipos de dados apresentados acima. Quando declaramos uma variável de referência seu conteúdo permanece vazio até que este seja criado com a instrução CREATE OBJECT ou CREATE DATA, ou então seja atribuída à uma variável que já existe com a instrução GET REFERENCE OF…INTO. A diferença entre CREATE DATA e CREATE OBJECT é que o primeiro é usado para criar referências à tipos de dados primários ou complexos, enquanto o segundo só funciona com classes ABAP. Segue abaixo um exemplo bem simples usando referências com um tipo de dado inteiro. DATA: lv_ref TYPE REF TO i, lv_value TYPE i. lv_value = 10. GET REFERENCE OF lv_value INTO lv_ref. WRITE lv_value. lv_ref-&amp;gt;* = 12. WRITE lv_value. Neste exemplo primeiro é impresso 10 e depois 12. Ou seja, o conteúdo da variável LV_VALUE foi alterado implicitamente, pois foi alteado pela variável de referência que estava apontando para ela. Este tipo de cenário é pouco explorado no ABAP, normalmente o uso mais visto para variáveis de referência é quando precisamos trabalhar com classes e objetos. Quando precisamos instanciar uma classe em ABAP fazemos o uso de CREATE OBJECT. Um exemplo bem familiar para muitos programadores ABAP é a classe CL_GUI_ALV_GRID que representa um elemento gráfico de um ALV (ABAP List Viewer, ou apenas Grid). DATA : lo_alv TYPE REF TO cl_gui_alv_grid. CREATE OBJECT lo_alv EXPORTING i_parent = lo_my_container. Neste cenário estamos criando uma instância em tempo de execução da classe CL_GUI_ALV_GRID e atribuindo-a à nossa variável de referência. É a partir deste momento que podemos fazer uso de seus métodos e propriedades sem resultado em um DUMP. O DUMP neste caso seria igual ao NullPointerException ou NullReferenceException do Java e C#, conhecem? Bônus: Constantes Não vou me estender muito neste assunto. Vou partir do princípio que você já sabe o que é uma constante e vou direto ao código que é o que interessa. CONSTANTS c_empresa(4) TYPE n VALUE 1001. Também é possível criar uma estrutura constante. Ficaria assim: CONSTANTS: BEGIN OF c_empresa, codigo(4) TYPE n VALUE &#39;1001&#39;, nome TYPE c VALUE &#39;SAP&#39; END OF c_empresa. WRITE: / c_empresa-codigo, c_empresa-nome. Espero que este post tenha sido útil. Até a próxima!" />
<link rel="canonical" href="https://goenning.net/2015/03/11/tipos-de-dados-variaveis-e-constantes/" />
<meta property="og:url" content="https://goenning.net/2015/03/11/tipos-de-dados-variaveis-e-constantes/" />
<meta property="og:site_name" content="@goenning" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-03-11T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Tipos de dados, variáveis e constantes" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"@goenning"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://goenning.net/2015/03/11/tipos-de-dados-variaveis-e-constantes/"},"@type":"BlogPosting","description":"Conhecer o fundamento dos tipos de dados e suas opções é essencial para podermos construir programas de qualidade, principalmente a partir da versão 4.5 onde a linguagem passou a suportar os modelos de programação estruturado e orientado a objetos de forma mista. Parece besteira, mas o funcionamento dos tipos de dados em ABAP possui uma diferença considerável quando comparada com outras linguagens. A imagem abaixo ajuda a enxergarmos todas as possibilidades. Note que a imagem acima quebra os tipos de dados em três categorias: Elementary Types, Complex Types e Reference Types. Vamos dar uma olhada em cada um deles e suas diferenças. Elementary Types Também conhecidos como tipos primitivos, estes são os famosos tipos de dados que encontramos em todas as linguagens. Temos o Inteiro, o Caractere, Data e Hora como bons exemplos. A definição de variáveis é feita com o comando DATA conforme mostra o exemplo abaixo. REPORT zvariaveis. DATA: cep(8) TYPE n, nome(20) TYPE c, idade TYPE i. Vale a pena ressaltar a diferença entre C (CHAR) e N (NUMC) que geralmente causa bastante confusão. N possui o mesmo comportamento do tipo C com a única diferença que este só pode armazenar valores numéricos. Ele ocupa a mesma quantidade de bytes em memória e é sempre representado com zeros à esquerda até preencher o comprimento total da variável. Também é possível utilizarmos variáveis deste tipo em operações matemáticas como adição, subtração e até comparação maior ou menor. No início pode parecer um tanto quanto estranho usar o tipo N se temos o I, mas ao longo do tempo você perceberá que a SAP faz uso extensivo deste de NUNC e logo você estará fazendo isto também. Nas chaves primárias de tabelas, por exemplo, sempre será utilizado NUMC. Um dos motivos para isto é justamente a garantia do tamanho fixo que este tipo de dado possui, pois em muitos lugares o SAP armazena a chave primária das tabelas de forma concatenada. Nestes casos é obrigatório que os campos da chave tenham um tamanho fixo para que seja possível fazer as devidas conversão na concatenaçao. Há ainda os tipos de dados de tamanho variável: STRING e XSTRING. Diferente de CHAR, o STRING pode crescer o quanto for necessário, sendo então o tipo de dado ideal para armazenar uma grande quantidade de texto como o conteúdo de um arquivo ou de um documento XML, por exemplo. Complex Types No ABAP também é possível criarmos nossas próprias estruturas de dados. Isto é muito útil quando é necessário agrupar um conjunto de informações em uma única variável. São dois passos para usar estas estruturas. A primeira é criar a estrutura usando a instrução TYPES. A segunda é criar uma instância deste tipo da mesma forma que fizemos até agora, usando a instrução DATA. REPORT zvariaveis. TYPES: BEGIN OF t_pessoa, nome(20) TYPE c, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. DATA: homem TYPE t_pessoa, mulher TYPE t_pessoa. homem-nome = &quot;Joao&quot;. homem-idade = 22. homem-peso = &#39;72.51&#39;. mulher-nome = &quot;Maria&quot;. mulher-idade = 19. mulher-peso = &#39;68.2&#39;. Para quem já trabalhou com outras linguagens, note que no ABAP o acesso aos campos é feito com hífen ao invés de ponto, isto causa bastante confusão em quem está inciando. O ‘ponto’ sempre será usado para definir o final de uma linha de código. Também é possível criarmos uma estrutura de dados que se comporta como uma hierarquia, onde o tipo de um campo referencia outro tipo complexo. Ahm?! Não entendeu? O exemplo abaixo deve ajudar na explicação. Transformei o campo nome em outra estrutura de dados. REPORT zvariaveis. TYPES: BEGIN OF t_nome, primeiro(20) TYPE c, ultimo(20) TYPE c, END OF t_nome, BEGIN OF t_pessoa, nome TYPE t_nome, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. DATA: homem TYPE t_pessoa, mulher TYPE t_pessoa. homem-nome-primeiro = &#39;Joao&#39;. homem-nome-ultimo = &#39;Braga&#39;. Ainda em se tratando de tipos complexos temos também as Tabelas Internas. A tabela interno é possivelmente um dos tipos de variável mais usado em programas ABAP, então se este assunto for novidade para você, sugiro estudá-lo e praticá-lo bastante. Uma tabela interno é muito semelhante a uma tabela de banco de dados. A grande diferença é que ela nasce e morre dentro de um contexto de um programa, ou seja, os dados inseridos nesta tabela não são armazenados em disco. Poderíamos chamá-las também de tabela temporária, porém este termo não é usado no ambiente ABAP. Quando trabalhamos com uma tabela interna é necessário declararmos uma variável do tipo tabela referenciando um outro tipo de dados, podendo ser um Elementary Type ou Complex Type. O tipo referenciado em uma tabela é conhecido como LINE TYPE. Veja o seguinte exemplo de declaração. REPORT zvariaveis. TYPES: BEGIN OF t_nome, primeiro(20) TYPE c, ultimo(20) TYPE c, END OF t_nome, BEGIN OF t_pessoa, nome TYPE t_nome, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. DATA: alunos TYPE STANDARD TABLE OF t_pessoa. Neste exemplo criei uma tabela chamada alunos onde o tipo da linha é t_pessoa. Esta variável/tabela pode conter uma quantidade infinita de registros, portanto torna-se útil quando não sabemos a quantidade de registros que precisamos. Se tivermos certeza de que será sempre dois registros, poderíamos criar duas variáveis básicas do tipo t_pessoa. No caso de um relatório de alunos matriculados em um curso, pode ser que tenhamos 1, 2, 3, 10, 40, 50 ou até mais alunos. Seria inviável criar uma variável para armazenar os dados de cada aluno, então este é um cenário onde devemos usar variáveis do tipo tabela. Comparando com outras linguagens, isto seria o mesmo que instanciar um objeto ArrayList (Java) ou List (C#) de uma classe qualquer. Para poder inserir registros nestas tabelas é necessário criar o que o ABAP chama de work area. Work area é uma variável do mesmo tipo de dado da tabela, porém representa apenas uma linha da tabela. Toda vez que for necessário inserir ou manipular um registro da tabela, é necessário fazer estas modificações primeiro na work area e depois repassar para a tabela. Confuso? Vamos ver se consigo explicar melhor com um exemplo. REPORT zvariaveis. TYPES: BEGIN OF t_nome, primeiro(20) TYPE c, ultimo(20) TYPE c, END OF t_nome, BEGIN OF t_pessoa, codigo type i, nome TYPE t_nome, idade TYPE i, peso TYPE p DECIMALS 2, END OF t_pessoa. * definição da tabela interna de alunos DATA: alunos TYPE STANDARD TABLE OF t_pessoa, * definição da work area para a tabela alunos wa_aluno type t_pessoa. * inserindo o primeiro registro de aluno na tabela de alunos wa_aluno-codigo = 1. wa_aluno-nome-primeiro = &#39;Albert&#39;. wa_aluno-nome-ultimo = &#39;Einstein&#39;. wa_aluno-idade = 42. wa_aluno-peso = &#39;70.2&#39;. insert wa_aluno into table alunos. * inserindo o segundo registro de aluno na tabela de alunos wa_aluno-codigo = 2. wa_aluno-nome-primeiro = &#39;Thomas&#39;. wa_aluno-nome-ultimo = &#39;Edison&#39;. wa_aluno-idade = 32. wa_aluno-peso = &#39;85.2&#39;. insert wa_aluno into table alunos. * mostrando na tela o nome completo e a idade dos dois alunos. LOOP AT alunos INTO wa_aluno. write: / wa_aluno-nome-primeiro, wa_aluno-nome-ultimo, wa_aluno-idade. ENDLOOP. * seleciona o aluno onde codigo for igual a 1 e o posiciona na work area READ table alunos INTO wa_aluno WITH KEY codigo = 1. IF sy-subrc = 0. * modifica a idade do aluno wa_aluno-idade = 30. * atualiza a tabela de alunos usando o indice encontrado na busca MODIFY alunos FROM wa_aluno INDEX sy-tabix. ENDIF. * mostrando na tela o nome completo dos dois alunos, com a idade atualizada LOOP AT alunos INTO wa_aluno. write: / wa_aluno-nome-primeiro, wa_aluno-nome-ultimo, wa_aluno-idade. ENDLOOP. Nestes exemplos eu sempre usei a tabela do tipo STANDARD. Mas também é possível usar HASHED ou SORTED. A diferença está na ordem com que os registros são inseridos e no desempenho durante os comandos de LOOP E READ TABLE. O artigo Performance de leitura por tipo de tabela explora bastante este assunto. Diferente formas de declarar uma variável. Em muitos exemplos de código na internet é possível notar o uso do comando LIKE na definição de uma variável. A diferença entre o TYPE e LIKE é que no TYPE você deve informar qual o tipo de dado da variável, eunquanto a declaração usando LIKE você informa uma outra variável existente para que esta nova variável copie a definição do tipo de dado. Este comando tornou-se obsoleto, pois não funciona com a versão orientada a objeto do ABAP. A SAP recomenda o uso de TYPE para todos os casos de declaração de variáveis. Também é muito comum encontrar exemplos onde a tabela interna é definida com HEADER LINE. Header line é uma forma de não ter que declarar uma work area para trabalhar com tabelas. Com o passar do tempo o uso de header line caiu em desuso e, apesar de ainda funcionar, não é mais recomendado. Reference Types Variáveis de referência foram adicionadas ao ABAP junto com o início do suporte à programação orientada à objetos. Referências são ponteiros que funcionam tanto para objetos quanto para os tipos de dados apresentados acima. Quando declaramos uma variável de referência seu conteúdo permanece vazio até que este seja criado com a instrução CREATE OBJECT ou CREATE DATA, ou então seja atribuída à uma variável que já existe com a instrução GET REFERENCE OF…INTO. A diferença entre CREATE DATA e CREATE OBJECT é que o primeiro é usado para criar referências à tipos de dados primários ou complexos, enquanto o segundo só funciona com classes ABAP. Segue abaixo um exemplo bem simples usando referências com um tipo de dado inteiro. DATA: lv_ref TYPE REF TO i, lv_value TYPE i. lv_value = 10. GET REFERENCE OF lv_value INTO lv_ref. WRITE lv_value. lv_ref-&amp;gt;* = 12. WRITE lv_value. Neste exemplo primeiro é impresso 10 e depois 12. Ou seja, o conteúdo da variável LV_VALUE foi alterado implicitamente, pois foi alteado pela variável de referência que estava apontando para ela. Este tipo de cenário é pouco explorado no ABAP, normalmente o uso mais visto para variáveis de referência é quando precisamos trabalhar com classes e objetos. Quando precisamos instanciar uma classe em ABAP fazemos o uso de CREATE OBJECT. Um exemplo bem familiar para muitos programadores ABAP é a classe CL_GUI_ALV_GRID que representa um elemento gráfico de um ALV (ABAP List Viewer, ou apenas Grid). DATA : lo_alv TYPE REF TO cl_gui_alv_grid. CREATE OBJECT lo_alv EXPORTING i_parent = lo_my_container. Neste cenário estamos criando uma instância em tempo de execução da classe CL_GUI_ALV_GRID e atribuindo-a à nossa variável de referência. É a partir deste momento que podemos fazer uso de seus métodos e propriedades sem resultado em um DUMP. O DUMP neste caso seria igual ao NullPointerException ou NullReferenceException do Java e C#, conhecem? Bônus: Constantes Não vou me estender muito neste assunto. Vou partir do princípio que você já sabe o que é uma constante e vou direto ao código que é o que interessa. CONSTANTS c_empresa(4) TYPE n VALUE 1001. Também é possível criar uma estrutura constante. Ficaria assim: CONSTANTS: BEGIN OF c_empresa, codigo(4) TYPE n VALUE &#39;1001&#39;, nome TYPE c VALUE &#39;SAP&#39; END OF c_empresa. WRITE: / c_empresa-codigo, c_empresa-nome. Espero que este post tenha sido útil. Até a próxima!","headline":"Tipos de dados, variáveis e constantes","dateModified":"2015-03-11T00:00:00-05:00","url":"https://goenning.net/2015/03/11/tipos-de-dados-variaveis-e-constantes/","datePublished":"2015-03-11T00:00:00-05:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/pt" class="site-avatar"><img width="70" height="70" alt="@goenning" src="https://avatars.githubusercontent.com/u/94755?s=210" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/pt">@goenning</a></h1>
            <p class="site-description">loop at { run; code; blog; swim; eat; cycle; } until tired;</p>
          </div>

          <nav>
            
              <a href="/pt">Blog</a>
            
              <a href="/arquivo">Arquivo</a>
            
              <a href="/projetos">Projetos</a>
            

            <div class="langs">
              
              
              
              
              
              <a href="/pt" title="Português" class="flag">
                <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 480" height="100%" width="100%">
  <g stroke-width="1pt">
    <path fill-rule="evenodd" fill="#229e45" d="M0 0h640v480H0z"/>
    <path d="M321.406 435.935l301.483-195.67-303.308-196.2L17.11 240.734l304.296 195.2z" fill-rule="evenodd" fill="#f8e509"/>
    <path d="M452.77 240.005c0 70.328-57.103 127.34-127.544 127.34-70.442 0-127.544-57.012-127.544-127.34s57.104-127.34 127.544-127.34c70.442 0 127.545 57.012 127.545 127.34z" fill-rule="evenodd" fill="#2b49a3"/>
    <path fill="#ffffef" fill-rule="evenodd" d="M283.3 316.274L279.357 314l-4.093 2.025.917-4.55-3.162-3.332 4.52-.53 2.124-4.08 1.894 4.22 4.46.81-3.345 3.13M368.77 337.917l-3.94-2.274-4.092 2.025.916-4.55-3.16-3.332 4.52-.53 2.122-4.08 1.894 4.22 4.46.81-3.345 3.13M331.93 303.343l-3.404-1.964-3.536 1.748.792-3.93-2.73-2.88 3.904-.457 1.834-3.523 1.636 3.645 3.853.7-2.89 2.705M418.254 290.91l-3.342-1.928-3.472 1.718.777-3.858-2.68-2.827 3.833-.45 1.8-3.46 1.607 3.58 3.783.686-2.837 2.657M330.37 265.03l-3.94-2.273-4.093 2.025.916-4.55-3.162-3.332 4.522-.53 2.123-4.08 1.894 4.22 4.46.81-3.346 3.13M225.13 225.52l-3.94-2.274-4.094 2.025.916-4.548-3.16-3.333 4.52-.53 2.122-4.08 1.894 4.22 4.46.81-3.345 3.13M237.786 278.08l-3.94-2.275-4.094 2.025.916-4.548-3.16-3.334 4.52-.53 2.123-4.08 1.894 4.22 4.46.81-3.345 3.132M369.114 206.17l-3.48-2.007-3.616 1.788.81-4.017-2.794-2.944 3.994-.47 1.875-3.603 1.673 3.728 3.94.715-2.955 2.766M361.896 240.366l-2.74-1.582-2.85 1.408.64-3.164-2.2-2.32 3.145-.368 1.477-2.838 1.318 2.936 3.103.563-2.327 2.18M219.263 287.603l-2.63-1.518-2.734 1.352.61-3.037-2.11-2.225 3.02-.354 1.416-2.723 1.264 2.818 2.978.54-2.233 2.09M418.984 299.71l-2.144-1.135-2.227 1.01.5-2.27-1.72-1.666 2.46-.265 1.154-2.038 1.03 2.108 2.426.404-1.82 1.563"/>
    <path fill="#ffffef" fill-rule="evenodd" d="M219.263 287.603l-2.63-1.518-2.734 1.352.61-3.037-2.11-2.225 3.02-.354 1.416-2.723 1.264 2.818 2.978.54-2.233 2.09"/>
    <path fill="#ffffef" fill-rule="evenodd" d="M219.263 287.603l-2.63-1.518-2.734 1.352.61-3.037-2.11-2.225 3.02-.354 1.416-2.723 1.264 2.818 2.978.54-2.233 2.09M261.143 287.594l-2.63-1.52-2.733 1.353.61-3.037-2.11-2.225 3.02-.354 1.416-2.722 1.265 2.817 2.978.54-2.233 2.09M255.94 301.525l-2.63-1.518-2.734 1.352.612-3.038-2.11-2.225 3.017-.354 1.417-2.724 1.265 2.817 2.977.54-2.233 2.09M342.902 276.164l-2.63-1.52-2.733 1.353.61-3.036-2.11-2.225 3.018-.353 1.417-2.724 1.265 2.817 2.977.54-2.233 2.09M317.384 276.154l-2.63-1.518-2.734 1.352.612-3.037-2.11-2.225 3.018-.353 1.417-2.724 1.264 2.817 2.98.54-2.234 2.09M248.167 267.258l-1.648-.952-1.714.847.384-1.902-1.323-1.394 1.89-.222.89-1.706.792 1.765 1.864.34-1.4 1.31M415.74 310.728l-2.63-1.518-2.733 1.35.612-3.035-2.11-2.226 3.017-.354 1.417-2.724 1.264 2.817 2.978.54-2.233 2.09M394.49 313.512l-2.178-1.26-2.264 1.122.507-2.522-1.748-1.848 2.5-.294 1.174-2.262 1.048 2.34 2.466.45-1.85 1.735M404.516 313.27l-2.03-1.173-2.108 1.044.472-2.344-1.63-1.718 2.33-.274 1.093-2.103.976 2.177 2.296.417-1.723 1.615M433.302 288.15l-1.955-1.13-2.03 1.006.454-2.257-1.567-1.655 2.243-.262 1.053-2.024.94 2.092 2.21.402-1.658 1.553M394.24 327.69l-2.554-1.395-2.652 1.24.594-2.786-2.05-2.043 2.93-.325 1.376-2.5 1.227 2.586 2.89.496-2.167 1.92M394.383 339.13l-2.33-1.395-2.418 1.24.542-2.786-1.87-2.044 2.673-.324 1.255-2.5 1.12 2.586 2.635.496-1.977 1.918M375.084 313.266l-1.955-1.13-2.032 1.006.455-2.257-1.568-1.653 2.242-.263 1.054-2.025.94 2.093 2.213.402-1.66 1.554M356.992 313.266l-1.954-1.13-2.03 1.006.454-2.257-1.57-1.653 2.244-.263 1.053-2.025.94 2.093 2.21.402-1.658 1.554M326.273 286.403l-1.955-1.128-2.03 1.004.454-2.257-1.568-1.654 2.243-.264 1.053-2.024.94 2.094 2.212.402-1.66 1.553M329.696 341.153l-1.656-.956-1.72.85.386-1.91-1.33-1.4 1.9-.223.893-1.715.795 1.772 1.874.34-1.407 1.316M283.3 252.597l-3.942-2.274-4.093 2.025.917-4.548-3.162-3.334 4.52-.53 2.124-4.08 1.894 4.22 4.46.81-3.345 3.132"/>
    <path d="M444.368 285.817c1.944-5.083 4.45-12.75 5.783-19.786-67.742-59.508-143.26-89.993-238.68-83.72-3.422 6.558-6.16 13.423-8.47 20.853 113.063-10.786 195.936 39.27 241.37 82.654z" fill-rule="evenodd" fill="#fff"/>
    <path d="M413.914 252.36l2.42 1.323c-.38.858-.48 1.61-.31 2.25.18.645.625 1.208 1.335 1.688.75.515 1.424.74 2.016.68.6-.06 1.045-.306 1.335-.734.183-.274.258-.563.225-.863-.027-.3-.192-.66-.495-1.075-.21-.28-.72-.873-1.53-1.777-1.04-1.16-1.66-2.138-1.86-2.936-.28-1.122-.11-2.14.51-3.06.4-.59.936-1.03 1.612-1.318.686-.29 1.433-.355 2.24-.198.81.157 1.664.54 2.55 1.143 1.453.987 2.33 2.048 2.63 3.184.305 1.138.117 2.253-.565 3.345l-2.404-1.484c.3-.665.375-1.24.218-1.723-.147-.485-.55-.95-1.21-1.397-.676-.46-1.302-.682-1.874-.663-.37.01-.654.168-.856.468-.186.277-.228.59-.13.943.13.45.668 1.193 1.625 2.234.953 1.04 1.604 1.89 1.95 2.547.355.657.516 1.34.482 2.05-.023.706-.284 1.427-.778 2.16-.45.667-1.053 1.163-1.812 1.493-.76.33-1.57.412-2.437.24-.86-.177-1.794-.607-2.798-1.29-1.462-.992-2.36-2.093-2.687-3.3-.322-1.213-.125-2.523.6-3.925zM402.436 244.827l2.472 1.22c-.345.872-.417 1.628-.22 2.26.208.637.672 1.183 1.4 1.635.775.482 1.455.68 2.043.596.6-.086 1.037-.346 1.306-.786.174-.28.236-.573.19-.87-.038-.302-.218-.655-.54-1.058-.22-.272-.75-.84-1.597-1.713-1.087-1.117-1.746-2.07-1.978-2.86-.323-1.11-.194-2.133.385-3.077.378-.606.896-1.066 1.56-1.38.674-.316 1.42-.413 2.23-.29.818.127 1.685.473 2.595 1.04 1.492.926 2.408 1.952 2.753 3.074.35 1.126.21 2.247-.427 3.365l-2.464-1.385c.275-.676.327-1.252.15-1.728-.168-.482-.59-.93-1.264-1.35-.697-.433-1.33-.628-1.9-.586-.37.025-.647.195-.838.504-.172.282-.204.594-.09.944.145.443.714 1.165 1.71 2.168.994 1 1.68 1.822 2.052 2.465.38.64.568 1.318.563 2.027.007.708-.227 1.437-.69 2.193-.42.68-1.008 1.202-1.75 1.565-.746.36-1.556.474-2.427.336-.865-.14-1.815-.536-2.848-1.175-1.498-.933-2.438-1.996-2.815-3.19-.374-1.2-.23-2.514.438-3.943zM388.23 241.02l7.276-11.966 8.837 5.416-1.23 2.026-6.43-3.942-1.615 2.652 5.983 3.668-1.225 2.015-5.984-3.667-1.977 3.256 6.657 4.08-1.228 2.017-9.063-5.557zM367.538 224.027l1.08-2.1 5.4 2.796-2.546 4.962c-.79.238-1.78.296-2.982.17-1.19-.13-2.295-.457-3.317-.986-1.3-.673-2.29-1.528-2.976-2.572-.683-1.05-1.01-2.205-.974-3.47.04-1.274.363-2.507.977-3.703.664-1.298 1.53-2.31 2.59-3.04 1.057-.727 2.25-1.09 3.57-1.09 1.008-.002 2.104.306 3.29.916 1.542.8 2.577 1.747 3.104 2.846.54 1.096.638 2.28.298 3.555l-2.728-.82c.14-.702.057-1.356-.25-1.957-.296-.606-.806-1.095-1.527-1.47-1.097-.567-2.146-.67-3.155-.305-1 .363-1.85 1.23-2.554 2.6-.76 1.48-1.005 2.76-.73 3.842.277 1.073.944 1.886 2.008 2.437.524.27 1.1.44 1.73.507.64.066 1.22.05 1.753-.05l.81-1.582-2.872-1.485zM277.296 201.648l2.034-13.867 4.172.62 1.123 9.826 3.86-9.093 4.188.618-2.033 13.87-2.59-.382 1.6-10.918-4.343 10.512-2.685-.398-1.134-11.32-1.6 10.915-2.592-.382zM263.188 200.01l1.305-13.96 10.307.974-.217 2.36-7.503-.706-.29 3.095 6.978.657-.22 2.352-6.98-.658-.353 3.8 7.764.73-.22 2.354-10.572-.998z" fill="#309e3a"/>
    <g stroke-opacity=".502">
      <path d="M216.5 191.28c.04-1.43.284-2.62.736-3.58.335-.703.786-1.332 1.346-1.884.566-.552 1.18-.956 1.844-1.21.88-.347 1.888-.505 3.023-.475 2.056.06 3.682.744 4.877 2.057 1.205 1.315 1.775 3.114 1.714 5.395-.06 2.26-.72 4.017-1.982 5.264-1.26 1.24-2.914 1.834-4.963 1.777-2.077-.056-3.708-.736-4.9-2.037-1.19-1.308-1.755-3.078-1.694-5.307z" fill="#309e3a"/>
      <path d="M219.414 191.252c-.043 1.586.29 2.8.997 3.643.708.837 1.625 1.27 2.748 1.3 1.122.03 2.055-.35 2.794-1.138.745-.797 1.14-2.007 1.184-3.633.043-1.605-.277-2.813-.96-3.622-.676-.81-1.595-1.23-2.757-1.262-1.162-.03-2.11.345-2.843 1.128-.733.777-1.12 1.972-1.163 3.584z" fill="#f7ffff"/>
    </g>
    <g stroke-opacity=".502">
      <path d="M233.052 198.51l.163-14.017 5.933.07c1.494.018 2.574.157 3.244.42.677.257 1.214.71 1.613 1.36s.593 1.385.584 2.215c-.013 1.052-.332 1.918-.956 2.598-.623.675-1.55 1.095-2.777 1.26.605.363 1.104.76 1.49 1.193.397.43.923 1.195 1.585 2.293l1.673 2.754-3.372-.04-2.002-3.074c-.71-1.098-1.198-1.788-1.46-2.072-.265-.29-.545-.487-.842-.593-.297-.11-.77-.17-1.418-.177l-.57-.008-.068 5.852-2.82-.033z" fill="#309e3a"/>
      <path d="M235.976 190.455l2.086.024c1.353.016 2.198-.03 2.536-.142.337-.112.603-.305.796-.584s.293-.627.3-1.048c.004-.472-.118-.853-.37-1.142-.243-.296-.594-.486-1.05-.567-.23-.034-.915-.06-2.057-.072l-2.2-.026-.04 3.555z" fill="#fff"/>
    </g>
    <g stroke-opacity=".502">
      <path d="M249.003 185.188l5.147.26c1.16.06 2.04.195 2.64.405.804.283 1.484.75 2.036 1.396.553.646.958 1.426 1.218 2.34.26.907.356 2.015.29 3.326-.058 1.153-.252 2.138-.58 2.96-.4 1-.938 1.797-1.618 2.396-.51.453-1.19.79-2.034 1.016-.632.166-1.468.222-2.51.17l-5.295-.27.706-14z" fill="#309e3a"/>
      <path d="M251.706 187.685l-.468 9.274 2.103.105c.786.042 1.357.025 1.71-.046.46-.093.85-.268 1.16-.526.32-.26.59-.695.81-1.31.223-.62.36-1.47.416-2.553s0-1.918-.16-2.507c-.16-.59-.404-1.053-.73-1.397-.327-.342-.75-.583-1.27-.724-.39-.11-1.157-.193-2.306-.25l-1.264-.067z" fill="#fff"/>
    </g>
    <g stroke-opacity=".502">
      <path d="M317.63 210.22l3.26-13.63 4.4 1.06c1.666.402 2.737.732 3.21.99.73.392 1.274.996 1.634 1.81.36.81.41 1.755.152 2.84-.2.836-.518 1.504-.958 2-.438.5-.932.854-1.48 1.07-.54.212-1.064.31-1.57.3-.685-.028-1.65-.19-2.89-.49l-1.786-.432-1.23 5.142-2.743-.66z" fill="#309e3a"/>
      <path d="M323.086 199.552l-.926 3.868 1.5.362c1.082.26 1.82.364 2.218.308.4-.055.736-.21 1.013-.464.283-.253.473-.58.568-.984.12-.496.073-.94-.14-1.33-.214-.395-.533-.684-.957-.87-.312-.143-.96-.332-1.95-.57l-1.324-.32z" fill="#fff"/>
    </g>
    <g stroke-opacity=".502">
      <path d="M330.606 214.106l4.64-13.22 5.598 1.98c1.408.498 2.387.98 2.937 1.445.56.463.923 1.064 1.093 1.807s.12 1.505-.156 2.286c-.348.992-.928 1.71-1.736 2.153-.806.438-1.817.537-3.032.298.457.54.802 1.076 1.03 1.61.238.536.49 1.43.765 2.683l.704 3.15-3.18-1.126-.913-3.556c-.322-1.27-.562-2.08-.72-2.435-.158-.36-.36-.638-.607-.834-.246-.202-.673-.41-1.286-.627l-.536-.192-1.938 5.52-2.66-.942z" fill="#309e3a"/>
      <path d="M335.938 207.426l1.967.695c1.276.452 2.09.68 2.445.683.355.005.67-.093.943-.295.272-.2.478-.5.616-.896.155-.445.162-.845.017-1.2-.135-.36-.408-.65-.813-.876-.206-.106-.847-.35-1.924-.73l-2.075-.736-1.177 3.356z" fill="#fff"/>
    </g>
    <g stroke-opacity=".502">
      <path d="M347.01 213.6c.424-1.363.982-2.444 1.673-3.24.517-.59 1.117-1.072 1.808-1.45.696-.377 1.397-.598 2.102-.665.94-.093 1.953.03 3.038.37 1.965.614 3.344 1.717 4.14 3.308.803 1.593.867 3.48.19 5.658-.67 2.162-1.78 3.67-3.33 4.528-1.548.852-3.302.97-5.26.357-1.982-.62-3.37-1.718-4.164-3.294-.793-1.583-.858-3.44-.196-5.57z" fill="#309e3a"/>
      <path d="M349.826 214.385c-.47 1.514-.48 2.773-.026 3.778.455.996 1.22 1.663 2.293 2 1.073.334 2.07.223 2.996-.336.932-.562 1.64-1.62 2.122-3.172.476-1.535.495-2.783.056-3.75-.432-.962-1.204-1.618-2.313-1.964-1.11-.347-2.123-.243-3.04.312-.915.548-1.61 1.592-2.09 3.133z" fill="#fff"/>
    </g>
    <g stroke-opacity=".502">
      <path d="M374.305 233.12l6.415-12.45 5.27 2.736c1.326.69 2.23 1.3 2.71 1.84.49.532.768 1.18.835 1.94s-.092 1.505-.47 2.242c-.48.934-1.153 1.564-2.017 1.892-.86.322-1.872.28-3.043-.128.378.598.645 1.18.8 1.74.158.564.288 1.484.387 2.763l.262 3.215-2.993-1.555-.415-3.648c-.145-1.304-.27-2.14-.378-2.512-.105-.377-.27-.682-.487-.91-.214-.233-.61-.5-1.186-.798l-.507-.264-2.677 5.197-2.505-1.3z" fill="#309e3a"/>
      <path d="M380.503 227.226l1.853.962c1.2.625 1.977.962 2.33 1.016.35.054.675 0 .973-.162.296-.16.54-.428.733-.803.216-.42.276-.814.184-1.186-.087-.374-.315-.702-.685-.98-.19-.134-.79-.465-1.808-.993l-1.952-1.013-1.63 3.16z" fill="#fff"/>
    </g>
    <g stroke-opacity=".502">
      <path d="M426.107 258.704c.797-1.183 1.642-2.056 2.536-2.62.662-.412 1.377-.7 2.146-.862.774-.16 1.507-.168 2.2-.028.93.184 1.864.596 2.805 1.235 1.704 1.156 2.708 2.612 3.014 4.366.31 1.758-.173 3.58-1.448 5.472-1.263 1.873-2.758 2.998-4.488 3.37-1.728.365-3.44-.028-5.14-1.182-1.718-1.168-2.732-2.622-3.04-4.362-.303-1.746.168-3.543 1.413-5.39z" fill="#309e3a"/>
      <path d="M428.578 260.254c-.886 1.316-1.256 2.518-1.112 3.61.15 1.087.69 1.945 1.62 2.578.932.632 1.92.815 2.967.55 1.055-.27 2.037-1.077 2.944-2.425.896-1.33 1.273-2.52 1.13-3.572-.138-1.047-.688-1.898-1.65-2.552s-1.962-.85-3-.583c-1.033.26-1.998 1.06-2.9 2.394z" fill="#fff"/>
    </g>
    <path d="M301.824 204.523l2.248-9.84 7.268 1.675-.378 1.662-5.287-1.217-.504 2.18 4.926 1.136-.382 1.655-4.918-1.132-.614 2.677 5.475 1.26-.378 1.66-7.456-1.717z" fill="#309e3a"/>
  </g>
</svg>

              </a>
              <a href="/" title="English" class="flag">
                <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 480" height="100%" width="100%">
  <defs>
    <clipPath id="a">
      <path fill-opacity=".67" d="M-85.333 0h682.67v512h-682.67z"/>
    </clipPath>
  </defs>
  <g clip-path="url(#a)" transform="matrix(.94 0 0 .94 80 0)">
    <g stroke-width="1pt">
      <path fill="#006" d="M-256 0H768.02v512.01H-256z"/>
      <path d="M-256 0v57.244l909.535 454.768H768.02V454.77L-141.515 0H-256zM768.02 0v57.243L-141.515 512.01H-256v-57.243L653.535 0H768.02z" fill="#fff"/>
      <path d="M170.675 0v512.01h170.67V0h-170.67zM-256 170.67v170.67H768.02V170.67H-256z" fill="#fff"/>
      <path d="M-256 204.804v102.402H768.02V204.804H-256zM204.81 0v512.01h102.4V0h-102.4zM-256 512.01L85.34 341.34h76.324l-341.34 170.67H-256zM-256 0L85.34 170.67H9.016L-256 38.164V0zm606.356 170.67L691.696 0h76.324L426.68 170.67h-76.324zM768.02 512.01L426.68 341.34h76.324L768.02 473.848v38.162z" fill="#c00"/>
    </g>
  </g>
</svg>

              </a>
            </div>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Tipos de dados, variáveis e constantes</h1>

  <small>
    


  11 de
  Março
      
  de 2015

    


  
    • 10 minutos para ler
  

    • 
  <a href="/tags/pt#abap">abap</a>

  </small>

  <div class="entry">
    <p>Conhecer o fundamento dos tipos de dados e suas opções é essencial para podermos construir programas de qualidade, principalmente a partir da versão 4.5 onde a linguagem passou a suportar os modelos de programação estruturado e orientado a objetos de forma mista. Parece besteira, mas o funcionamento dos tipos de dados em ABAP possui uma diferença considerável quando comparada com outras linguagens.</p>

<p>A imagem abaixo ajuda a enxergarmos todas as possibilidades.</p>

<p><img src="/public/images/2015/03/abap-data-types.gif" alt="" /></p>

<p>Note que a imagem acima quebra os tipos de dados em três categorias: <strong>Elementary Types</strong>, <strong>Complex Types</strong> e <strong>Reference Types</strong>. Vamos dar uma olhada em cada um deles e suas diferenças.</p>

<h2 id="elementary-types">Elementary Types</h2>

<p>Também conhecidos como tipos primitivos, estes são os famosos tipos de dados que encontramos em todas as linguagens. Temos o Inteiro, o Caractere, Data e Hora como bons exemplos.</p>

<p>A definição de variáveis é feita com o comando DATA conforme mostra o exemplo abaixo.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REPORT zvariaveis.
DATA: cep(8) TYPE n,
      nome(20) TYPE c,
      idade TYPE i.
</code></pre></div></div>

<p>Vale a pena ressaltar a diferença entre C (CHAR) e N (NUMC) que geralmente causa bastante confusão. N possui o mesmo comportamento do tipo C com a única diferença que este só pode armazenar valores numéricos. Ele ocupa a mesma quantidade de bytes em memória e é sempre representado com zeros à esquerda até preencher o comprimento total da variável. Também é possível utilizarmos variáveis deste tipo em operações matemáticas como adição, subtração e até comparação maior ou menor.</p>

<p>No início pode parecer um tanto quanto estranho usar o tipo N se temos o I, mas ao longo do tempo você perceberá que a SAP faz uso extensivo deste de NUNC e logo você estará fazendo isto também. Nas chaves primárias de tabelas, por exemplo, sempre será utilizado NUMC. Um dos motivos para isto é justamente a garantia do tamanho fixo que este tipo de dado possui, pois em muitos lugares o SAP armazena a chave primária das tabelas de forma concatenada. Nestes casos é obrigatório que os campos da chave tenham um tamanho fixo para que seja possível fazer as devidas conversão na concatenaçao.</p>

<p>Há ainda os tipos de dados de tamanho variável: <strong>STRING</strong> e <strong>XSTRING</strong>. Diferente de CHAR, o STRING pode crescer o quanto for necessário, sendo então o tipo de dado ideal para armazenar uma grande quantidade de texto como o conteúdo de um arquivo ou de um documento XML, por exemplo.</p>

<h2 id="complex-types">Complex Types</h2>

<p>No ABAP também é possível criarmos nossas próprias estruturas de dados. Isto é muito útil quando é necessário agrupar um conjunto de informações em uma única variável.</p>

<p>São dois passos para usar estas estruturas. A primeira é criar a estrutura usando a instrução TYPES. A segunda é criar uma instância deste tipo da mesma forma que fizemos até agora, usando a instrução DATA.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REPORT  zvariaveis.
TYPES: BEGIN OF t_pessoa,
    nome(20) TYPE c,
    idade TYPE i,
    peso TYPE p DECIMALS 2,
  END OF t_pessoa.

DATA: homem TYPE t_pessoa,
      mulher TYPE t_pessoa.

homem-nome = "Joao".
homem-idade = 22.
homem-peso = '72.51'.

mulher-nome = "Maria".
mulher-idade = 19.
mulher-peso = '68.2'.
</code></pre></div></div>

<p>Para quem já trabalhou com outras linguagens, note que no ABAP o acesso aos campos é feito com hífen ao invés de ponto, isto causa bastante confusão em quem está inciando. O ‘ponto’ sempre será usado para definir o final de uma linha de código.</p>

<p>Também é possível criarmos uma estrutura de dados que se comporta como uma hierarquia, onde o tipo de um campo referencia outro tipo complexo. Ahm?! Não entendeu? O exemplo abaixo deve ajudar na explicação. Transformei o campo nome em outra estrutura de dados.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REPORT  zvariaveis.
TYPES:
  BEGIN OF t_nome,
    primeiro(20) TYPE c,
    ultimo(20) TYPE c,
  END OF t_nome,
  BEGIN OF t_pessoa,
    nome TYPE t_nome,
    idade TYPE i,
    peso TYPE p DECIMALS 2,
  END OF t_pessoa.

DATA: homem TYPE t_pessoa,
      mulher TYPE t_pessoa.

homem-nome-primeiro = 'Joao'.
homem-nome-ultimo = 'Braga'.
</code></pre></div></div>

<p>Ainda em se tratando de tipos complexos temos também as <strong>Tabelas Internas</strong>. A tabela interno é possivelmente um dos tipos de variável mais usado em programas ABAP, então se este assunto for novidade para você, sugiro estudá-lo e praticá-lo bastante.</p>

<p>Uma tabela interno é muito semelhante a uma tabela de banco de dados. A grande diferença é que ela nasce e morre dentro de um contexto de um programa, ou seja, os dados inseridos nesta tabela não são armazenados em disco. Poderíamos chamá-las também de tabela temporária, porém este termo não é usado no ambiente ABAP.</p>

<p>Quando trabalhamos com uma tabela interna é necessário declararmos uma variável do tipo tabela referenciando um outro tipo de dados, podendo ser um Elementary Type ou Complex Type. O tipo referenciado em uma tabela é conhecido como <strong>LINE TYPE</strong>. Veja o seguinte exemplo de declaração.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REPORT  zvariaveis.
TYPES:
  BEGIN OF t_nome,
    primeiro(20) TYPE c,
    ultimo(20) TYPE c,
  END OF t_nome,
  BEGIN OF t_pessoa,
    nome TYPE t_nome,
    idade TYPE i,
    peso TYPE p DECIMALS 2,
  END OF t_pessoa.

DATA: alunos TYPE STANDARD TABLE OF t_pessoa.
</code></pre></div></div>

<p>Neste exemplo criei uma tabela chamada alunos onde o tipo da linha é t_pessoa.</p>

<p>Esta variável/tabela pode conter uma quantidade infinita de registros, portanto torna-se útil quando não sabemos a quantidade de registros que precisamos. Se tivermos certeza de que será sempre dois registros, poderíamos criar duas variáveis básicas do tipo t_pessoa. No caso de um relatório de alunos matriculados em um curso, pode ser que tenhamos 1, 2, 3, 10, 40, 50 ou até mais alunos. Seria inviável criar uma variável para armazenar os dados de cada aluno, então este é um cenário onde devemos usar variáveis do tipo tabela.</p>

<p>Comparando com outras linguagens, isto seria o mesmo que instanciar um objeto ArrayList (Java) ou List (C#) de uma classe qualquer.</p>

<p>Para poder inserir registros nestas tabelas é necessário criar o que o ABAP chama de <strong>work area</strong>. Work area é uma variável do mesmo tipo de dado da tabela, porém representa apenas uma linha da tabela. Toda vez que for necessário inserir ou manipular um registro da tabela, é necessário fazer estas modificações primeiro na work area e depois repassar para a tabela. Confuso? Vamos ver se consigo explicar melhor com um exemplo.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REPORT zvariaveis.

TYPES:
  BEGIN OF t_nome,
    primeiro(20) TYPE c,
    ultimo(20) TYPE c,
  END OF t_nome,
  BEGIN OF t_pessoa,
    codigo type i,
    nome TYPE t_nome,
    idade TYPE i,
    peso TYPE p DECIMALS 2,
  END OF t_pessoa.

* definição da tabela interna de alunos
DATA: alunos TYPE STANDARD TABLE OF t_pessoa,
* definição da work area para a tabela alunos
      wa_aluno type t_pessoa.

* inserindo o primeiro registro de aluno na tabela de alunos
wa_aluno-codigo = 1.
wa_aluno-nome-primeiro = 'Albert'.
wa_aluno-nome-ultimo = 'Einstein'.
wa_aluno-idade = 42.
wa_aluno-peso = '70.2'.
insert wa_aluno into table alunos.

* inserindo o segundo registro de aluno na tabela de alunos
wa_aluno-codigo = 2.
wa_aluno-nome-primeiro = 'Thomas'.
wa_aluno-nome-ultimo = 'Edison'.
wa_aluno-idade = 32.
wa_aluno-peso = '85.2'.
insert wa_aluno into table alunos.

* mostrando na tela o nome completo e a idade dos dois alunos.
LOOP AT alunos INTO wa_aluno.
 write: / wa_aluno-nome-primeiro, wa_aluno-nome-ultimo, wa_aluno-idade.
ENDLOOP.

* seleciona o aluno onde codigo for igual a 1 e o posiciona na work area
READ table alunos INTO wa_aluno WITH KEY codigo = 1.
IF sy-subrc = 0.
* modifica a idade do aluno
  wa_aluno-idade = 30.
* atualiza a tabela de alunos usando o indice encontrado na busca  
  MODIFY alunos FROM wa_aluno INDEX sy-tabix.
ENDIF.

* mostrando na tela o nome completo dos dois alunos, com a idade atualizada
LOOP AT alunos INTO wa_aluno.
 write: / wa_aluno-nome-primeiro, wa_aluno-nome-ultimo, wa_aluno-idade.
ENDLOOP.
</code></pre></div></div>

<p>Nestes exemplos eu sempre usei a tabela do tipo STANDARD. Mas também é possível usar HASHED ou SORTED. A diferença está na ordem com que os registros são inseridos e no desempenho durante os comandos de LOOP E READ TABLE. O artigo <a href="/2015/03/18/performance-de-leitura-por-tipo-de-tabela/" title="Performance de leitura por tipo de tabela">Performance de leitura por tipo de tabela</a> explora bastante este assunto.</p>

<h4 id="diferente-formas-de-declarar-uma-variável">Diferente formas de declarar uma variável.</h4>

<p>Em muitos exemplos de código na internet é possível notar o uso do comando LIKE na definição de uma variável. A diferença entre o TYPE e LIKE é que no TYPE você deve informar qual o tipo de dado da variável, eunquanto a declaração usando LIKE você informa uma outra variável existente para que esta nova variável copie a definição do tipo de dado. Este comando tornou-se obsoleto, pois não funciona com a versão orientada a objeto do ABAP. A SAP recomenda o uso de TYPE para todos os casos de declaração de variáveis.</p>

<p>Também é muito comum encontrar exemplos onde a tabela interna é definida com HEADER LINE. Header line é uma forma de não ter que declarar uma work area para trabalhar com tabelas. Com o passar do tempo o uso de header line caiu em desuso e, apesar de ainda funcionar, não é mais recomendado.</p>

<h2 id="reference-types">Reference Types</h2>

<p>Variáveis de referência foram adicionadas ao ABAP junto com o início do suporte à programação orientada à objetos. Referências são ponteiros que funcionam tanto para objetos quanto para os tipos de dados apresentados acima. Quando declaramos uma variável de referência seu conteúdo permanece vazio até que este seja criado com a instrução <strong>CREATE OBJECT</strong> ou <strong>CREATE DATA</strong>, ou então seja atribuída à uma variável que já existe com a instrução <strong>GET REFERENCE OF…INTO</strong>. A diferença entre CREATE DATA e CREATE OBJECT é que o primeiro é usado para criar referências à tipos de dados primários ou complexos, enquanto o segundo só funciona com classes ABAP.</p>

<p>Segue abaixo um exemplo bem simples usando referências com um tipo de dado inteiro.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DATA: lv_ref   TYPE REF TO i,
      lv_value TYPE i.

lv_value = 10.
GET REFERENCE OF lv_value INTO lv_ref.
WRITE lv_value. 

lv_ref-&amp;gt;* = 12.

WRITE lv_value.
</code></pre></div></div>

<p>Neste exemplo primeiro é impresso 10 e depois 12. Ou seja, o conteúdo da variável LV_VALUE foi alterado implicitamente, pois foi alteado pela variável de referência que estava apontando para ela.</p>

<p>Este tipo de cenário é pouco explorado no ABAP, normalmente o uso mais visto para variáveis de referência é quando precisamos trabalhar com classes e objetos. Quando precisamos instanciar uma classe em ABAP fazemos o uso de CREATE OBJECT. Um exemplo bem familiar para muitos programadores ABAP é a classe <strong>CL_GUI_ALV_GRID</strong> que representa um elemento gráfico de um ALV (ABAP List Viewer, ou apenas Grid).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DATA : lo_alv TYPE REF TO cl_gui_alv_grid.
 
CREATE OBJECT lo_alv
  EXPORTING
    i_parent = lo_my_container.
</code></pre></div></div>

<p>Neste cenário estamos criando uma instância em tempo de execução da classe CL_GUI_ALV_GRID e atribuindo-a à nossa variável de referência. É a partir deste momento que podemos fazer uso de seus métodos e propriedades sem resultado em um DUMP. O DUMP neste caso seria igual ao NullPointerException ou NullReferenceException do Java e C#, conhecem?</p>

<h2 id="bônus-constantes">Bônus: Constantes</h2>

<p>Não vou me estender muito neste assunto. Vou partir do princípio que você já sabe o que é uma constante e vou direto ao código que é o que interessa.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CONSTANTS c_empresa(4) TYPE n VALUE 1001.
</code></pre></div></div>

<p>Também é possível criar uma estrutura constante. Ficaria assim:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CONSTANTS: BEGIN OF c_empresa,
            codigo(4) TYPE n VALUE '1001',
            nome TYPE c VALUE 'SAP'
           END OF c_empresa.

WRITE: / c_empresa-codigo, c_empresa-nome.
</code></pre></div></div>

<p>Espero que este post tenha sido útil.</p>

<p>Até a próxima!</p>

  </div>
  <a href="https://twitter.com/intent/tweet?text=Tipos+de+dados%2C+vari%C3%A1veis+e+constantes+by+@goenning&url=https%3A%2F%2Fgoenning.net%2F2015%2F03%2F11%2Ftipos-de-dados-variaveis-e-constantes%2F">Discuss on Twitter</a> <small>•</small> <a href="https://github.com/goenning/goenning.github.io/tree/master/_posts/2015/2015-03-11-tipos-de-dados-variaveis-e-constantes.md">Edit on GitHub</a>
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          <a href="mailto:me@goenning.net" aria-label="Email" target="_blank" rel="noopener"><i class="svg-icon email"></i></a>
<a href="https://github.com/goenning" aria-label="GitHub" target="_blank" rel="noopener"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/goenning" aria-label="LinkedIn" target="_blank" rel="noopener"><i class="svg-icon linkedin"></i></a>
<a href="/feed.xml" aria-label="RSS Feed" target="_blank" rel="noopener"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/goenning" aria-label="Twitter" target="_blank" rel="noopener"><i class="svg-icon twitter"></i></a>




        </footer>
      </div>
    </div>
  </body>
</html>
